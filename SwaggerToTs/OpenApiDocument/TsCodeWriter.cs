using System.Text;

namespace SwaggerToTs.OpenApiDocument;

public class TsCodeWriter
{
  private static TsCodeWriter? _writer;
  private readonly List<TsCodeElement> _codes = new();
  private readonly OpenApiObject _openApiObject;

  public readonly HashSet<string> OperationExportNames = new();
  public readonly Dictionary<string, TsCodeElement> RefMappingCode = new();
  private readonly string? _outputPath;

  private readonly List<string>? _tagsToIgnore;
  
  public bool TryToGuessRequired { get; set; }

  private readonly List<string>? _tagsToMatch;

  private const string Warning = @"/**
 * This file was auto-generated by the program based on the back-end data structrue.
 * Do not make direct changes to the file.
 */";

  private TsCodeWriter(string outputPath, int printWidth, List<string>? tagsToIgnore, List<string>? tagsToMatch,
    bool tryToGuessRequired,
    OpenApiObject openApiObject)
  {
    _outputPath = outputPath;
    PrintWidth = printWidth;
    _tagsToIgnore = tagsToIgnore;
    TryToGuessRequired = tryToGuessRequired;
    _tagsToMatch = tagsToMatch;
    _openApiObject = openApiObject;
    ComponentsObject = openApiObject.Components;
  }

  public static string OneOfName = "OneOf";
  public static string AnyOfName = "AnyOf";

  private static readonly string HelperContent = $@"/* eslint-disable @typescript-eslint/no-explicit-any */
type IntersectionTuple<S, T extends any[]> = T extends [infer F, ...infer R]
  ? [S & F, ...IntersectionTuple<S, R>]
  : T;

type Permutations<T extends readonly unknown[]> = T['length'] extends 0 | 1
  ? T
  : T extends [infer F, ...infer R]
  ? [F, ...IntersectionTuple<F, Permutations<R>>, ...Permutations<R>]
  : T;

type AllKeysOf<T> = T extends any ? keyof T : never;

type ProhibitKeys<K extends keyof any> = {{ [P in K]?: never }};

export type {OneOfName}<T extends any[]> = {{
  [K in keyof T]: T[K] &
    ProhibitKeys<Exclude<AllKeysOf<T[number]>, keyof T[K]>>;
}}[number];

export type {AnyOfName}<T extends any[]> = OneOf<Permutations<T>>;
";

  private const string HelperLocate = "common/helper";
  
  public ComponentsObject? ComponentsObject { get; set; }
  public int PrintWidth { get; set; }
  public HashSet<string> OperationIds { get; set; } = new();

  public static TsCodeWriter Get()
  {
    if (_writer == null) throw new Exception("writer is null");

    return _writer;
  }

  public static TsCodeWriter Create(string outputPath, int printWidth, List<string>? tagsToIgnore,
    List<string>? tagsToMatch, bool? tryToGuessRequired,OpenApiObject openApiObject)
  {
    if (_writer == null || _writer._openApiObject != openApiObject)
      _writer = new TsCodeWriter(outputPath, printWidth, tagsToIgnore, tagsToMatch, tryToGuessRequired ?? false, openApiObject);
    return _writer;
  }


  public bool Match(OperationObject operationObject)
  {
    if (_tagsToMatch == null) return true;
    return MatchTags(operationObject, _tagsToMatch);
  }

  public bool Ignore(OperationObject operationObject)
  {
    if (_tagsToIgnore == null) return false;
    return MatchTags(operationObject, _tagsToIgnore);
  }

  private bool MatchTags(OperationObject operationObject, List<string> tags)
  {
    return tags.Any(tag =>
      operationObject.Tags.Exists(e => string.Equals(e, tag, StringComparison.CurrentCultureIgnoreCase)));
  }

  public void Add(TsCodeElement element)
  {
    _codes.Add(element);
  }

  private string GetOrSetFileLocateIfNotExists(TsCodeElement element)
  {
    if (element.FileLocate != null) return element.FileLocate;

    HashSet<string> file = new();
    foreach (var codeReference in element.References) file.Add(GetOrSetFileLocateIfNotExists(codeReference));

    string fileLocate;

    if (file.Count == 1)
    {
      fileLocate = file.First();
      element.Priority = 1;
    }
    else
    {
      fileLocate = element.DefaultFileLocate ?? throw new InvalidOperationException();
    }

    element.FileLocate = fileLocate;
    return fileLocate;
  }


  private string GetRelativePath(string baseFile, string fileToImport)
  {
    var pathCount = baseFile.Split("/").Length - 1;
    StringBuilder sb = new();
    for (var i = 0; i < pathCount; i++) sb.Append("../");

    if (sb.Length == 0) fileToImport = $"./{fileToImport}";

    return sb + fileToImport;
  }

  private string CreateImport(List<string> imports, string fileLocate, string fileToImport,
    bool exclusiveRow = false)
  {
    var separator = exclusiveRow ? TsCodeElement.NewLine + "  " : " ";
    var content =
      $@"import {{{separator}{string.Join("," + separator, imports)}{(exclusiveRow ? TsCodeElement.NewLine : " ")}}} from '{GetRelativePath(fileLocate, fileToImport)}';";
    if (!exclusiveRow && content.Length > PrintWidth) return CreateImport(imports, fileLocate, fileToImport, true);

    return content;
  }

  public void Write(Dictionary<string, string> contents)
  {
    var dir = new DirectoryInfo(_outputPath ?? throw new InvalidOperationException());
    if (dir.Exists) dir.Delete(true);

    foreach (var (fileLocate, content) in contents)
    {
      Directory.CreateDirectory(Path.GetDirectoryName(fileLocate) ?? throw new InvalidOperationException());
      File.WriteAllText(fileLocate, content);
    }
  }

  public Dictionary<string, string> Generate()
  {
    if (_outputPath == null) throw new Exception("target dir null");

    _openApiObject.GenerateTsCode();
    Dictionary<string, List<TsCodeElement>> fileMappingOutput = new();
    Dictionary<string, string> fileMappingText = new();
    foreach (var code in _codes)
    {
      code.FileLocate = GetOrSetFileLocateIfNotExists(code);
      fileMappingOutput.GetOrCreate(code.FileLocate).Add(code);
    }

    foreach (var (fileLocate, outputs) in fileMappingOutput)
    {
      SortedDictionary<string, HashSet<string>> imports = new();
      StringBuilder contents = new();
      StringBuilder importBlock = new();
      HashSet<string> dup = new();
      outputs.Sort((x, y) =>
      {
        if (x.Priority != y.Priority) return x.Priority.CompareTo(y.Priority);

        return string.Compare(x.ExportName, y.ExportName, StringComparison.Ordinal);
      });
      foreach (var output in outputs)
      {
        if (string.IsNullOrEmpty(output.ExportName)) throw new Exception("empty Export name");

        if (dup.Contains(output.ExportName))
          throw new Exception($"dup export name {output.ExportName} in {fileLocate}");

        dup.Add(output.ExportName);
        foreach (var codeDependency in output.Imports)
        {
          var dependencyLocate = GetOrSetFileLocateIfNotExists(codeDependency);
          if (codeDependency.ExportName == null) throw new Exception("code to export should not have empty value");

          if (dependencyLocate != fileLocate) imports.GetOrCreate(dependencyLocate).Add(codeDependency.ExportName);
        }

        foreach (var helperName in output.HelpersToImport)
        {
          imports.GetOrCreate(HelperLocate).Add(helperName);
          fileMappingText.TryAdd(GetFullPath(HelperLocate), HelperContent);
        }

        if (contents.Length > 0) contents.AppendLine();

        contents.AppendLine(output.ExportContent);
      }

      foreach (var (fileToImport, importName) in imports)
      {
        var x = importName.ToList();
        x.Sort((s, s1) => string.Compare(s, s1, StringComparison.Ordinal));
        importBlock.AppendLine(CreateImport(x, fileLocate, fileToImport));
      }

      if (importBlock.Length > 0) importBlock.AppendLine();

      var target = GetFullPath(fileLocate);
      fileMappingText.Add(target, Warning + TsCodeElement.NewLine + TsCodeElement.NewLine + importBlock + contents);
    }


    return fileMappingText;
  }

  private string GetFullPath(string fileLocate )
  {
    return  Path.Combine(_outputPath ?? throw new InvalidOperationException(), fileLocate + ".ts");
  }
}